--- /mnt/data/config.py+++ /mnt/data/fixed_files/config.py@@ -1,15 +1,30 @@ import os
+import logging
 from dotenv import load_dotenv
+from typing import Optional
 
 load_dotenv()
 
+logger = logging.getLogger(__name__)
+
 def get_env_int(name: str, default: int = 0) -> int:
+    v = os.getenv(name)
+    if v is None:
+        return default
     try:
-        return int(os.getenv(name, default))
+        return int(v)
     except (TypeError, ValueError):
+        logger.warning("Env %s should be int, got %r; using default %s", name, v, default)
         return default
 
-TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
+def require_env(name: str) -> str:
+    v = os.getenv(name)
+    if not v:
+        raise RuntimeError(f"Required env var {name} is not set")
+    return v
+
+# Core
+TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")  # may be None during tests
 BASEROW_URL = os.getenv("BASEROW_URL", "http://baserow:80")
 BASEROW_JWT = os.getenv("BASEROW_JWT")
 BASEROW_DATABASE_ID = get_env_int("BASEROW_DATABASE_ID", 1)
@@ -18,3 +33,8 @@ KOKORO_URL = os.getenv("KOKORO_URL", "http://kokoro:8880")
 KOKORO_VOICE = os.getenv("KOKORO_VOICE", "af_bella")
 MANAGER_TELEGRAM_ID = get_env_int("MANAGER_TELEGRAM_ID", 0)
+
+def validate_config():
+    """Call at startup to ensure required secrets are present in prod."""
+    if not TELEGRAM_TOKEN or TELEGRAM_TOKEN.startswith("YOUR_") or TELEGRAM_TOKEN.strip() == "":
+        raise RuntimeError("TELEGRAM_TOKEN is missing or placeholder. Set it via env or .env file.")

--- /mnt/data/logic.py+++ /mnt/data/fixed_files/logic.py@@ -1,26 +1,47 @@-    from typing import Dict, Any
-    from bot.services.llm_g4f import LLM
-    from bot.services.memory import Memory
+import asyncio
+import inspect
+import logging
+from typing import Dict, Any, Optional
+from bot.services.llm_g4f import LLM
+from bot.services.memory import Memory
 
-    llm = LLM()
-    memory = Memory()
+logger = logging.getLogger(__name__)
 
-    def build_system_prompt(role: str, policy_text: str) -> str:
-        return (
-            "Ты помощник внутри CRM агентства недвижимости. "
-            "Строго следуй инструкции и бизнес-логике. "
-            "Всегда спрашивай подтверждение перед изменениями в БД. "
-            f"Твоя роль: {role}. Инструкция:
-{policy_text[:6000]}"
-        )
+llm = LLM()
+memory = Memory()
 
-    def ai_reply(role: str, user_text: str, policy_text: str) -> str:
-        sys = build_system_prompt(role, policy_text)
-        answer = llm.chat([
+def build_system_prompt(role: str, policy_text: Optional[str]) -> str:
+    safe_policy = policy_text or ""
+    return (
+        "Ты помощник внутри CRM агентства недвижимости. "
+        "Строго следуй инструкции и бизнес-логике. "
+        "Всегда спрашивай подтверждение перед изменениями в БД. "
+        f"Твоя роль: {role}. Инструкция:\n{safe_policy[:6000]}"
+    )
+
+async def _maybe_await(value):
+    if inspect.isawaitable(value) or asyncio.iscoroutine(value):
+        return await value
+    return value
+
+async def ai_reply(role: str, user_text: str, policy_text: Optional[str]) -> str:
+    sys = build_system_prompt(role, policy_text)
+    try:
+        res = llm.chat([
             {"role": "system", "content": sys},
             {"role": "user", "content": user_text}
         ])
-        return answer
+        answer = await _maybe_await(res)
+        if answer is None:
+            return "Извините, ИИ не вернул ответ."
+        return str(answer)
+    except Exception as e:
+        logger.exception("LLM chat error")
+        return f"⚠️ Ошибка при обращении к ИИ: {e}"
 
-    def remember(user_id: int, role: str, text: str, meta: Dict[str, Any]):
-        memory.upsert_dialog(user_id, role, text, meta)
+async def remember(user_id: int, role: str, text: str, meta: Dict[str, Any]):
+    try:
+        res = memory.upsert_dialog(user_id, role, text, meta)
+        await _maybe_await(res)
+    except Exception as e:
+        logger.exception("Memory upsert error")

--- /mnt/data/main.py+++ /mnt/data/fixed_files/main.py@@ -1,11 +1,14 @@ import asyncio
 import logging
+import datetime
+import inspect
+import sys
 from aiogram import Bot, Dispatcher, F
 from aiogram.fsm.storage.redis import RedisStorage
-from aiogram.types import Message, CallbackQuery
+from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
 import redis.asyncio as aioredis
 
-from bot.config import TELEGRAM_TOKEN, REDIS_HOST, MANAGER_TELEGRAM_ID
+from bot.config import TELEGRAM_TOKEN, REDIS_HOST, MANAGER_TELEGRAM_ID, validate_config
 from bot.ui import main_menu, submenu
 from bot.services.baserow_client import Baserow
 from bot.logic import ai_reply, remember
@@ -16,9 +19,16 @@ from bot.services.finance import FinanceService
 from bot.services.memory import Memory
 from bot.scheduler import start_scheduler
-import datetime
-
+
+logger = logging.getLogger(__name__)
 logging.basicConfig(level=logging.INFO)
+
+# validate required envs in prod
+try:
+    validate_config()
+except Exception as e:
+    logger.warning("Config validation failed: %s", e)
+
 baserow = Baserow()
 policy_text = load_policy_text()
 tasks_svc = TasksService(baserow)
@@ -26,37 +36,59 @@ finance_svc = FinanceService(baserow)
 memory = Memory()
 
+async def _maybe_await(value):
+    if inspect.isawaitable(value) or asyncio.iscoroutine(value):
+        return await value
+    return value
+
 async def ensure_tables_and_fields():
-    existing = {t['name']: t['id'] for t in baserow.list_tables()}
+    try:
+        res = baserow.list_tables()
+        tables = await _maybe_await(res)
+        existing = {t['name']: t['id'] for t in (tables or [])}
+    except Exception as e:
+        logger.exception("Failed to list baserow tables: %s", e)
+        existing = {}
+
     for tbl_name, fields in TABLE_DEFINITIONS.items():
         if tbl_name not in existing:
-            tid = baserow.create_table(tbl_name)
-            if tid:
-                existing[tbl_name] = tid
+            try:
+                tid = baserow.create_table(tbl_name)
+                tid = await _maybe_await(tid)
+                if tid:
+                    existing[tbl_name] = tid
+            except Exception:
+                logger.exception("Failed to create table %s", tbl_name)
+                continue
         tid = existing.get(tbl_name)
         if not tid:
             continue
         for f in fields:
             try:
-                baserow.ensure_field(tid, f['name'], f['type'])
+                r = baserow.ensure_field(tid, f['name'], f['type'])
+                await _maybe_await(r)
             except Exception:
+                logger.exception("Failed ensure_field %s on %s", f['name'], tbl_name)
                 continue
 
-async def on_startup(bot):
+async def on_startup(bot: Bot):
     await ensure_tables_and_fields()
 
 async def main():
+    if not TELEGRAM_TOKEN:
+        logger.error("TELEGRAM_TOKEN not set. Exiting.")
+        sys.exit(1)
+
     redis_pool = aioredis.from_url(f"redis://{REDIS_HOST}:6379", decode_responses=True)
     storage = RedisStorage(redis=redis_pool)
     bot = Bot(token=TELEGRAM_TOKEN)
     dp = Dispatcher(storage=storage)
 
     loop = asyncio.get_event_loop()
-    # start scheduler
     start_scheduler(loop, bot)
 
     @dp.message(F.command("start"))
-    async def start(m: Message):
+    async def start_handler(m: Message):
         kb = main_menu()
         await m.answer("Выберите раздел (используйте inline-кнопки):", reply_markup=kb)
 
@@ -72,17 +104,23 @@     @dp.callback_query(F.data.startswith("table:"))
     async def open_table(c: CallbackQuery):
         _, tbl_name = c.data.split(":", 1)
-        tid = baserow.get_table_id_by_name(tbl_name)
+        try:
+            tid = baserow.get_table_id_by_name(tbl_name)
+            tid = await _maybe_await(tid)
+        except Exception:
+            tid = None
         if not tid:
             await c.answer("Таблица не найдена", show_alert=True)
             return
-        rows = baserow.list_rows(tid, size=100).get("results", [])
+        rows_res = baserow.list_rows(tid, size=100)
+        rows_res = await _maybe_await(rows_res)
+        rows = (rows_res or {}).get("results", []) if isinstance(rows_res, dict) else (rows_res or [])
         if not rows:
             await c.message.answer(f"Таблица «{tbl_name}» пуста.")
         else:
             lines = []
             for r in rows[:20]:
-                lines.append(str({k: v for k, v in r.items() if not k.startswith('_')}))
+                lines.append(str({k: v for k, v in r.items() if not str(k).startswith('_')}))
             await c.message.answer(f"«{tbl_name}» (первые 20):\n" + "\n".join(lines))
 
     @dp.callback_query(F.data.startswith("action:"))
@@ -101,79 +139,116 @@             await redis_pool.delete(key)
             group, action = r.split("|", 1)
             if group == "Задачи" and action == "Добавить задачу":
-                tasks_svc.add_task(title="Задача", details=m.text, assigned_to=m.from_user.id, created_by=m.from_user.id)
+                try:
+                    tasks_svc.add_task(
+                        title="Задача",
+                        details=m.text,
+                        assigned_to=m.from_user.id,
+                        created_by=m.from_user.id
+                    )
+                except Exception:
+                    logger.exception("Failed to add task")
                 await m.answer("Задача добавлена ✅")
                 return
             if group == "Отчетность" and action == "Создать отчет":
-                tid = baserow.get_table_id_by_name("Собрание, рабочие процессы")
-                if tid:
-                    baserow.create_row(tid, {"title": "Отчет", "notes": m.text, "date": datetime.datetime.utcnow().isoformat(), "owner_tg": m.from_user.id})
+                rep_tid = baserow.get_table_id_by_name("Собрание, рабочие процессы")
+                rep_tid = await _maybe_await(rep_tid)
+                if rep_tid:
+                    try:
+                        baserow.create_row(rep_tid, {
+                            "title": "Отчет",
+                            "notes": m.text,
+                            "date": datetime.datetime.utcnow().isoformat(),
+                            "owner_tg": m.from_user.id
+                        })
+                    except Exception:
+                        logger.exception("Failed to create report row")
                 if MANAGER_TELEGRAM_ID:
-                    await bot.send_message(MANAGER_TELEGRAM_ID, f"Ежедневный отчет от {m.from_user.full_name}:\n{m.text}")
+                    await bot.send_message(
+                        MANAGER_TELEGRAM_ID,
+                        f"Ежедневный отчет от {m.from_user.full_name}:\n{m.text}"
+                    )
                 await m.answer("Отчет сформирован и отправлен руководителю ✅")
                 return
 
-        # AI reply
-        reply = ai_reply(role, m.text, policy_text)
+        # AI reply (awaited)
+        reply = await ai_reply(role, m.text, policy_text)
         await m.answer(reply)
 
-        remember(m.from_user.id, role, m.text, {"source": "text"})
-
-        # TTS attempt skipped here to avoid blocking
+        await remember(m.from_user.id, role, m.text, {"source": "text"})
 
     @dp.callback_query(F.data == "action:Отчетность:Закончить рабочий день")
-async def finish_workday_request(c: CallbackQuery):
-    uid = c.from_user.id
-    today = datetime.date.today().isoformat()
-    tid = baserow.get_table_id_by_name("Успешные Сделки")
-    total_comm = 0
-    cnt = 0
-    if tid:
-        rows = baserow.list_rows(tid, size=1000).get("results", [])
-        for r in rows:
+    async def finish_workday_request(c: CallbackQuery):
+        uid = c.from_user.id
+        today = datetime.date.today().isoformat()
+        tid = await _maybe_await(baserow.get_table_id_by_name("Успешные Сделки"))
+        total_comm, cnt = 0, 0
+        if tid:
+            rows_res = await _maybe_await(baserow.list_rows(tid, size=1000))
+            rows = (rows_res or {}).get("results", []) if isinstance(rows_res, dict) else (rows_res or [])
+            for r in rows:
+                try:
+                    if int(r.get("agent_id") or 0) == uid and (r.get("date") or "").startswith(today):
+                        total_comm += int(r.get("commission_amount") or 0)
+                        cnt += 1
+                except Exception:
+                    continue
+        cash_tid = await _maybe_await(baserow.get_table_id_by_name("Общак"))
+        my_fines = 0
+        if cash_tid:
+            rows_res = await _maybe_await(baserow.list_rows(cash_tid, size=1000))
+            rows = (rows_res or {}).get("results", []) if isinstance(rows_res, dict) else (rows_res or [])
+            for r in rows:
+                try:
+                    if int(r.get("from_agent") or 0) == uid and (r.get("date") or "").startswith(today) and r.get("type") == "Штраф":
+                        my_fines += int(r.get("amount") or 0)
+                except Exception:
+                    continue
+        net = total_comm - my_fines
+        report_text = f"Отчет за {today} для {c.from_user.full_name}:\nСделки: {cnt} (комиссия {total_comm}), штрафы: {my_fines}, чистыми: {net}"
+        await redis_pool.set(f"pending_finish:{uid}", report_text, ex=3600)
+        kb = InlineKeyboardMarkup(inline_keyboard=[[
+            InlineKeyboardButton(text="✅ Подтвердить и отправить", callback_data="confirm_finish:yes"),
+            InlineKeyboardButton(text="❌ Отмена", callback_data="confirm_finish:no")
+        ]])
+        await c.message.answer(report_text)
+        await c.message.answer("Подтвердите завершение рабочего дня:", reply_markup=kb)
+
+    @dp.callback_query(F.data.startswith("confirm_finish:"))
+    async def confirm_finish_handler(c: CallbackQuery):
+        action = c.data.split(":", 1)[1]
+        uid = c.from_user.id
+        pending = await redis_pool.get(f"pending_finish:{uid}")
+        if action == "no" or not pending:
+            await c.message.answer("Операция отменена.")
+            await redis_pool.delete(f"pending_finish:{uid}")
+            return
+        report_text = pending
+        if MANAGER_TELEGRAM_ID:
+            await bot.send_message(MANAGER_TELEGRAM_ID, report_text)
+        rep_tid = await _maybe_await(baserow.get_table_id_by_name("Собрание, рабочие процессы"))
+        if rep_tid:
             try:
-                if int(r.get("agent_id") or 0) == uid and (r.get("date") or "").startswith(today):
-                    total_comm += int(r.get("commission_amount") or 0)
-                    cnt += 1
+                baserow.create_row(rep_tid, {
+                    "title": f"Отчет {c.from_user.full_name}",
+                    "notes": report_text,
+                    "date": datetime.datetime.utcnow().isoformat(),
+                    "owner_tg": uid
+                })
             except Exception:
-                continue
-    cash_tid = baserow.get_table_id_by_name("Общак")
-    my_fines = 0
-    if cash_tid:
-        rows = baserow.list_rows(cash_tid, size=1000).get("results", [])
-        for r in rows:
-            try:
-                if int(r.get("from_agent") or 0) == uid and (r.get("date") or "").startswith(today) and r.get("type") == "Штраф":
-                    my_fines += int(r.get("amount") or 0)
-            except Exception:
-                continue
-    net = total_comm - my_fines
-    report_text = f"Отчет за {today} для {c.from_user.full_name}:\nСделки: {cnt} (комиссия {total_comm}), штрафы: {my_fines}, чистыми: {net}"
-    # store pending report in redis for confirmation
-    await redis_pool.set(f"pending_finish:{uid}", report_text, ex=3600)
-    from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
-    kb = InlineKeyboardMarkup(inline_keyboard=[[
-        InlineKeyboardButton(text="✅ Подтвердить и отправить", callback_data="confirm_finish:yes"),
-        InlineKeyboardButton(text="❌ Отмена", callback_data="confirm_finish:no")
-    ]])
-    await c.message.answer(report_text)
-    await c.message.answer("Подтвердите завершение рабочего дня:", reply_markup=kb)
-
-@dp.callback_query(F.data.startswith("confirm_finish:"))
-async def confirm_finish_handler(c: CallbackQuery):
-    action = c.data.split(":", 1)[1]
-    uid = c.from_user.id
-    pending = await redis_pool.get(f"pending_finish:{uid}")
-    if action == "no" or not pending:
-        await c.message.answer("Операция отменена.")
+                logger.exception("Failed to create confirm_finish row")
+        await c.message.answer("Рабочий день завершён. Отчет отправлен руководителю.")
         await redis_pool.delete(f"pending_finish:{uid}")
-        return
-    # send to manager and save to Baserow
-    report_text = pending
-    if MANAGER_TELEGRAM_ID:
-        await bot.send_message(MANAGER_TELEGRAM_ID, report_text)
-    rep_tid = baserow.get_table_id_by_name("Собрание, рабочие процессы")
-    if rep_tid:
-        baserow.create_row(rep_tid, {"title": f"Отчет {c.from_user.full_name}", "notes": report_text, "date": datetime.datetime.utcnow().isoformat(), "owner_tg": uid})
-    await c.message.answer("Рабочий день завершён. Отчет отправлен руководителю.")
-    await redis_pool.delete(f"pending_finish:{uid}")
+
+    # Polling loop
+    try:
+        await on_startup(bot)
+        await dp.start_polling(bot, skip_updates=True)
+    except (KeyboardInterrupt, SystemExit):
+        logger.info("Shutting down...")
+    finally:
+        await bot.session.close()
+        await redis_pool.close()
+
+if __name__ == "__main__":
+    asyncio.run(main())

--- /mnt/data/scheduler.py+++ /mnt/data/fixed_files/scheduler.py@@ -1,8 +1,17 @@+import asyncio
+import inspect
+import logging
 from apscheduler.schedulers.asyncio import AsyncIOScheduler
 from bot.services.finance import FinanceService
 from bot.services.baserow_client import Baserow
 from bot.config import MANAGER_TELEGRAM_ID
-import asyncio
+
+logger = logging.getLogger(__name__)
+
+async def _maybe_await(val):
+    if inspect.isawaitable(val):
+        return await val
+    return val
 
 def start_scheduler(loop, bot):
     scheduler = AsyncIOScheduler(event_loop=loop)
@@ -10,17 +19,42 @@     finance = FinanceService(baserow)
 
     async def daily_report_job():
-        t = baserow.get_table_id_by_name("Успешные Сделки")
-        if not t:
-            return
-        rows = baserow.list_rows(t, size=1000).get("results", [])
-        agents = set(int(r.get("agent_id") or 0) for r in rows if r.get("agent_id"))
-        text = "Ежедневный автоматический отчет по агентам:\n"
-        for a in agents:
-            s = finance.summary_for_agent(a)
-            text += f"Agent {a}: доходы {s['income']}, штрафы {s['penalties']}, чистыми {s['net']}\n"
-        if MANAGER_TELEGRAM_ID:
-            await bot.send_message(MANAGER_TELEGRAM_ID, text)
+        try:
+            t = await _maybe_await(baserow.get_table_id_by_name("Успешные Сделки"))
+            if not t:
+                return
+            rows_res = await _maybe_await(baserow.list_rows(t, size=1000))
+            rows = (rows_res or {}).get("results", []) if isinstance(rows_res, dict) else (rows_res or [])
+            agents = set()
+            for r in rows:
+                try:
+                    aid = int(r.get("agent_id") or 0)
+                    if aid:
+                        agents.add(aid)
+                except Exception:
+                    continue
+            if not agents:
+                return
+            text = "Ежедневный автоматический отчет по агентам:\n"
+            for a in agents:
+                try:
+                    s = await _maybe_await(finance.summary_for_agent(a))
+                    if isinstance(s, dict):
+                        income = s.get("income")
+                        penalties = s.get("penalties")
+                        net = s.get("net")
+                    else:
+                        income = getattr(s, "income", None)
+                        penalties = getattr(s, "penalties", None)
+                        net = getattr(s, "net", None)
+                    text += f"Agent {a}: доходы {income}, штрафы {penalties}, чистыми {net}\n"
+                except Exception:
+                    logger.exception("Error collecting summary for agent %s", a)
+                    text += f"Agent {a}: ошибка при сборе данных\n"
+            if MANAGER_TELEGRAM_ID:
+                await bot.send_message(MANAGER_TELEGRAM_ID, text)
+        except Exception:
+            logger.exception("daily_report_job failure")
 
     scheduler.add_job(daily_report_job, "cron", hour=23, minute=59)
     scheduler.start()

--- /mnt/data/auth.py+++ /mnt/data/fixed_files/auth.py@@ -1,18 +1,31 @@ from functools import wraps
 from aiogram import types
 from bot.config import MANAGER_TELEGRAM_ID
+import logging
+
+logger = logging.getLogger(__name__)
 
 def manager_only(func):
     @wraps(func)
     async def wrapper(obj, *args, **kwargs):
         user_id = None
-        if isinstance(obj, types.Message) or isinstance(obj, types.CallbackQuery):
+        if isinstance(obj, types.Message):
             user_id = obj.from_user.id
+        elif isinstance(obj, types.CallbackQuery):
+            user_id = obj.from_user.id
+        else:
+            try:
+                maybe = args[0]
+                if hasattr(maybe, "from_user"):
+                    user_id = maybe.from_user.id
+            except Exception:
+                user_id = None
+
         if user_id != MANAGER_TELEGRAM_ID:
             try:
                 await obj.answer("Доступ запрещен: только руководитель.", show_alert=True)
             except Exception:
-                pass
+                logger.exception("Failed to send manager_only response")
             return
         return await func(obj, *args, **kwargs)
     return wrapper

--- /mnt/data/policy_loader.py+++ /mnt/data/fixed_files/policy_loader.py@@ -1,16 +1,26 @@ import os
-from docx import Document
+import logging
+
+logger = logging.getLogger(__name__)
 
 def load_policy_text() -> str:
     path = os.environ.get("POLICY_DOCX_PATH", "/app/policy/rules.docx")
     if not os.path.exists(path):
+        logger.info("Policy docx not found at %s", path)
+        return ""
+    try:
+        from docx import Document
+    except Exception:
+        logger.exception("python-docx not installed")
         return ""
     try:
         doc = Document(path)
         txt = []
         for p in doc.paragraphs:
-            if p.text.strip():
-                txt.append(p.text.strip())
+            t = p.text.strip()
+            if t:
+                txt.append(t)
         return "\n".join(txt)
     except Exception:
+        logger.exception("Failed to load policy docx %s", path)
         return ""

--- /mnt/data/ui.py+++ /mnt/data/fixed_files/ui.py@@ -3,16 +3,14 @@ 
 def main_menu():
     kb = InlineKeyboardMarkup(inline_keyboard=[])
-    # Таблицы
     row = []
-    for i, name in enumerate(TABLES, start=1):
+    for name in TABLES:
         row.append(InlineKeyboardButton(text=name, callback_data=f"table:{name}"))
         if len(row) == 2:
             kb.inline_keyboard.append(row)
             row = []
     if row:
         kb.inline_keyboard.append(row)
-    # Подменю
     kb.inline_keyboard.append([
         InlineKeyboardButton(text="Задачи ▾", callback_data="submenu:Задачи"),
         InlineKeyboardButton(text="Объекты ▾", callback_data="submenu:Объекты"),

--- a/.env.example+++ /mnt/data/fixed_files/.env.example@@ -0,0 +1,10 @@+# .env.example - DO NOT commit real secrets
+TELEGRAM_TOKEN=YOUR_TELEGRAM_BOT_TOKEN
+BASEROW_URL=http://baserow:80
+BASEROW_JWT=YOUR_BASEROW_JWT
+BASEROW_DATABASE_ID=1
+QDRANT_URL=http://qdrant:6333
+REDIS_HOST=redis
+KOKORO_URL=http://kokoro:8880
+KOKORO_VOICE=af_bella
+MANAGER_TELEGRAM_ID=5269660483

--- a/Dockerfile.prod+++ /mnt/data/fixed_files/Dockerfile.prod@@ -0,0 +1,28 @@+# Production Dockerfile
+FROM python:3.11-slim
+
+ENV PYTHONUNBUFFERED=1             POETRY_VIRTUALENVS_CREATE=false
+
+# system deps (if any)
+RUN apt-get update && apt-get install -y --no-install-recommends \
+    build-essential ca-certificates wget git \
+    && rm -rf /var/lib/apt/lists/*
+
+WORKDIR /app
+
+# install pip requirements if requirements.txt exists, otherwise expect install step
+COPY pyproject.toml poetry.lock* /app/
+# If you use pip requirements, copy requirements.txt and run pip install -r requirements.txt
+RUN pip install --upgrade pip
+RUN pip install --no-cache-dir poetry || true
+# Install dependencies in a virtual-less environment
+RUN if [ -f /app/pyproject.toml ]; then poetry install --no-dev --no-interaction --no-ansi; fi
+
+# Copy app
+COPY . /app
+
+# Create non-root user
+RUN useradd --create-home appuser && chown -R appuser /app
+USER appuser
+
+CMD ["python", "-u", "main.py"]

--- a/docker-compose.override.yml+++ /mnt/data/fixed_files/docker-compose.override.yml@@ -0,0 +1,19 @@+version: '3.8'
+services:
+  bot:
+    build:
+      context: .
+      dockerfile: Dockerfile.prod
+    env_file:
+      - .env
+    restart: unless-stopped
+    depends_on:
+      - redis
+      - baserow
+    deploy:
+      resources:
+        limits:
+          cpus: '1.0'
+          memory: 512M
+    healthcheck:
+      test: ["CMD", "python", "-c", "import sys; sys.exit(0)"]
